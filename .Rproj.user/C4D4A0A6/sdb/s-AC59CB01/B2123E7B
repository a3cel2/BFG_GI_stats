{
    "collab_server" : "",
    "contents" : "differential_gi_analysis <- function(gi_data,\n                                     fdr_cutoff = 0.05,\n                                     require_sign_change = F,\n                                     nn_pair_type = 'broad'){\n  gi_data <-\n    dplyr::filter(gi_data, Remove_by_Chromosomal_distance_or_SameGene == 'no')\n  \n  \n  if(nn_pair_type == 'broad'){\n    #Can define all non DNA_repair - DNA_repair as neutral\n    nn_pairs <-\n      gi_data$Type_of_gene_i != 'DNA_repair' | gi_data$Type_of_gene_j != 'DNA_repair'\n  }else if(nn_pair_type == 'narrow'){\n    #Or just neutral-neutral pairs\n    nn_pairs <-\n      gi_data$Type_of_gene_i == 'Neutral' &\n      gi_data$Type_of_gene_j == 'Neutral'\n  }\n  \n  ddr_pairs <-\n    gi_data$Type_of_gene_i == 'DNA_repair' &\n    gi_data$Type_of_gene_j == 'DNA_repair'\n  \n  \n  z_cols <- grep('Class',grep('Z_GIS',colnames(gi_data),val=T),invert=T,val=T)\n  \n  \n  conditions <- sapply(strsplit(grep('^GIS',colnames(gi_data),val=T),split='\\\\.'),function(x){x[2]})\n  \n  \n  ret_list <- list()\n  ret_df <- c()\n  \n  for(condition1 in conditions) {\n    ret_list[[condition1]] <- list()\n    for (condition2 in conditions) {\n      if (condition1 > condition2) {\n        \n        z_name1 <- paste(c('Z_GIS_ij', condition1), collapse = '.')\n        z_name2 <- paste(c('Z_GIS_ij', condition2), collapse = '.')\n        \n        z_class_name1 <- paste(c(z_name1,'Class'),collapse='_')\n        z_class_name2 <- paste(c(z_name2,'Class'),collapse='_')\n        \n        nn_scores_cond <-\n          gi_data[nn_pairs, z_name1] - gi_data[nn_pairs, z_name2]\n        \n        non_nn_scores_cond <-\n          gi_data[ddr_pairs, z_name1] - gi_data[ddr_pairs, z_name2]\n        \n        unequal_tests <- c(`>=`, `<=`)\n        precision_list <- lapply(unequal_tests, function(unequal_test) {\n          mu <- mean(nn_scores_cond)\n          sigma <- sd(nn_scores_cond)\n          #sapply(1:length(non_nn_scores_cond), function(i) {\n          sapply(1:length(non_nn_scores_cond), function(i) {\n            observed <-\n              sum(unequal_test(non_nn_scores_cond, non_nn_scores_cond[i]))\n            if (all.equal(unequal_test, `<=`) == T) {\n              use_lower_tail <- T\n            } else{\n              use_lower_tail <- F\n            }\n            \n            #Using normal distribuion to calculate expected\n            expected <-\n              pnorm(\n                non_nn_scores_cond[i],\n                mean = mu,\n                sd = sigma,\n                lower.tail = use_lower_tail\n              )\n            \n            \n            #expected <- sum(unequal_test(nn_scores_cond, non_nn_scores_cond[i]))/length(non_nn_scores_cond)\n            expected <- expected * length(non_nn_scores_cond)\n            \n            fdr <- (expected / observed)\n            \n            #No sense returning fdr estimates >100%\n            return(min(fdr, 1))\n          })\n        })\n        fdrs_pos <- precision_list[[1]]\n        fdrs_neg <- precision_list[[2]]\n        comb_fdr <- cbind(fdrs_pos, fdrs_neg)\n        \n        #Return positive or negative FDRs based on the nominal sign\n        #of the interaction\n        fdr_scores <- sapply(1:nrow(comb_fdr), function(i) {\n          if (non_nn_scores_cond[i] < 0) {\n            return(fdrs_neg[i])\n          } else{\n            return(fdrs_pos[i])\n          }\n        })\n        \n        if(require_sign_change){\n          sig <- fdr_scores < fdr_cutoff & gi_data[ddr_pairs,z_class_name1] != gi_data[ddr_pairs,z_class_name2]\n        }else{\n          sig <- fdr_scores < fdr_cutoff\n        }\n\n        ddr_data <- gi_data[ddr_pairs,]\n        \n        sig_names <- apply(ddr_data[which(sig),1:2],1,function(x){paste(x,collapse='_')})\n        \n        ret_list[[condition1]][[condition2]] <- sig_names\n        \n        \n        \n        retvec <- cbind(ddr_data[which(sig),c(\"Barcode_i\",\"Barcode_j\")],\n                        rep(condition1,sum(sig)),\n                        rep(condition2,sum(sig)),\n                        ddr_data[which(sig),c(z_name1,z_name2)],\n                        ddr_data[which(sig),c(z_class_name1,z_class_name2)],\n                        non_nn_scores_cond[which(sig)],\n                        fdr_scores[which(sig)])\n        \n        colnames(retvec) <- c('Barcode_i','Barcode_j','Condition1','Condition2','Z_Condition1','Z_Condition2','Class_Condition1','Class_Condition2','DeltaZ','DeltaZ_FDR')\n        \n        ret_df <- rbind(ret_df,retvec)\n      }\n    }\n  }\n  return(ret_df)\n}\n\n\n",
    "created" : 1514925174912.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3745225330",
    "id" : "B2123E7B",
    "lastKnownWriteTime" : 1514932532,
    "last_content_update" : 1514932532659,
    "path" : "~/Dropbox/Roth Lab/projects/BFG_GI_stats/packages/BfgGiStats/R/differential_gi_calls.R",
    "project_path" : "packages/BfgGiStats/R/differential_gi_calls.R",
    "properties" : {
        "tempName" : "Untitled5"
    },
    "relative_order" : 10,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}