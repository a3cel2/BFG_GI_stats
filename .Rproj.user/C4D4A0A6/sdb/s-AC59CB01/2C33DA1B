{
    "collab_server" : "",
    "contents" : "\n\n\n\n\n\ngi_data <-\n  dplyr::filter(gi_data, Remove_by_Chromosomal_distance_or_SameGene == 'no')\n\nnn_pairs <-\n  gi_data$Type_of_gene_i != 'DNA_repair' | gi_data$Type_of_gene_j != 'DNA_repair'\n\nddr_pairs <-\n  gi_data$Type_of_gene_i == 'DNA_repair' &\n  gi_data$Type_of_gene_j == 'DNA_repair'\n\n\nz_cols <- grep('Class',grep('Z_GIS',colnames(gi_data),val=T),invert=T,val=T)\n\n\nconditions <- sapply(strsplit(grep('^GIS',colnames(gi_data),val=T),split='\\\\.'),function(x){x[2]})\n\n\nret_list <- list()\nret_df <- c()\n\nfor(condition1 in conditions) {\n  ret_list[[condition1]] <- list()\n  for (condition2 in conditions) {\n    if (condition1 > condition2) {\n      \n      z_name1 <- paste(c('Z_GIS_ij', condition1), collapse = '.')\n      z_name2 <- paste(c('Z_GIS_ij', condition2), collapse = '.')\n      \n      z_class_name1 <- paste(c(z_name1,'Class'),collapse='_')\n      z_class_name2 <- paste(c(z_name2,'Class'),collapse='_')\n      \n      nn_scores_cond <-\n        gi_data[nn_pairs, z_name1] - gi_data[nn_pairs, z_name2]\n      \n      non_nn_scores_cond <-\n        gi_data[ddr_pairs, z_name1] - gi_data[ddr_pairs, z_name2]\n      \n      unequal_tests <- c(`>=`, `<=`)\n      precision_list <- lapply(unequal_tests, function(unequal_test) {\n        mu <- mean(nn_scores_cond)\n        sigma <- sd(nn_scores_cond)\n        sapply(1:length(non_nn_scores_cond), function(i) {\n          observed <-\n            sum(unequal_test(non_nn_scores_cond, non_nn_scores_cond[i]))\n          if (all.equal(unequal_test, `<=`) == T) {\n            use_lower_tail <- T\n          } else{\n            use_lower_tail <- F\n          }\n          \n          #Using normal distribuion to calculate expected\n          expected <-\n            pnorm(\n              non_nn_scores_cond[i],\n              mean = mu,\n              sd = sigma,\n              lower.tail = use_lower_tail\n            )\n          \n          \n          #expected <- sum(unequal_test(nn_scores_cond, non_nn_scores_cond[i]))/length(non_nn_scores_cond)\n          expected <- expected * length(non_nn_scores_cond)\n          \n          fdr <- (expected / observed)\n          \n          #No sense returning fdr estimates >100%\n          return(min(fdr, 1))\n        })\n      })\n      fdrs_pos <- precision_list[[1]]\n      fdrs_neg <- precision_list[[2]]\n      comb_fdr <- cbind(fdrs_pos, fdrs_neg)\n      \n      #Return positive or negative FDRs based on the nominal sign\n      #of the interaction\n      fdr_scores <- sapply(1:nrow(comb_fdr), function(i) {\n        if (non_nn_scores_cond[i] < 0) {\n          return(fdrs_neg[i])\n        } else{\n          return(fdrs_pos[i])\n        }\n      })\n      \n      print(c(condition1,condition2))\n      #non_nn_scores_cond\n      sig <- fdr_scores < 0.05 & gi_data[ddr_pairs,z_class_name1] != gi_data[ddr_pairs,z_class_name2]\n      print(sum(sig))\n      \n      ddr_data <- gi_data[ddr_pairs,]\n      \n      sig_names <- apply(ddr_data[which(sig),1:2],1,function(x){paste(x,collapse='_')})\n\n      ret_list[[condition1]][[condition2]] <- sig_names\n      \n      \n      \n      retvec <- cbind(ddr_data[which(sig),c(\"Barcode_i\",\"Barcode_j\")],\n                      rep(condition1,sum(sig)),\n                      rep(condition2,sum(sig)),\n                      ddr_data[which(sig),c(z_name1,z_name2)],\n                      ddr_data[which(sig),c(z_class_name1,z_class_name2)],\n                      non_nn_scores_cond[which(sig)],\n                      fdr_scores[which(sig)])\n      \n      colnames(retvec) <- c('Barcode_i','Barcode_j','Condition1','Condition2','Z_Condition1','Z_Condition2','Class_Condition1','Class_Condition2','DeltaZ','DeltaZ_FDR')\n      \n      ret_df <- rbind(ret_df,retvec)\n      \n      #ret_df <- rbind(ret_df\n      \n      #print(sum(abs(non_nn_scores_cond) > 0 & gi_data[ddr_pairs,z_class_name1] != gi_data[ddr_pairs,z_class_name2]))\n    }\n  }\n}\n\nstop()\n\n#sapply(conditions,function(condition1))\n\n\n#z_differential\n\n\n\n\nnn_scores_cond <- gi_data[nn_pairs,'Z_GIS_ij.ZEOC'] - gi_data[nn_pairs,'Z_GIS_ij.BLMC']\nnon_nn_scores_cond <- gi_data[ddr_pairs,'Z_GIS_ij.ZEOC'] - gi_data[ddr_pairs,'Z_GIS_ij.BLMC']\n\n#stop()\n\nunequal_tests <- c(`>=`,`<=`)\nprecision_list <- lapply(unequal_tests,function(unequal_test){\n  mu <- mean(nn_scores_cond)\n  sigma <- sd(nn_scores_cond)\n  sapply(1:length(non_nn_scores_cond),function(i){\n    \n    \n    observed <- sum(unequal_test(non_nn_scores_cond, non_nn_scores_cond[i]))\n    if(all.equal(unequal_test,`<=`) == T){\n      use_lower_tail <- T\n    }else{\n      use_lower_tail <- F\n    }\n    \n    #Using normal distribuion to calculate expected\n    expected <- pnorm(non_nn_scores_cond[i],mean=mu,sd=sigma,lower.tail=use_lower_tail)\n    \n    \n    #expected <- sum(unequal_test(nn_scores_cond, non_nn_scores_cond[i]))/length(non_nn_scores_cond)\n    expected <- expected*length(non_nn_scores_cond)\n    \n    fdr <- (expected/observed)\n    \n    #No sense returning fdr estimates >100%\n    return(min(fdr,1))\n  })\n})\n\nstop()\n\n \n# \n# fdr_matrix <- cbind(fdr_matrix,fdr_scores)",
    "created" : 1508787787928.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "3098268244",
    "id" : "2C33DA1B",
    "lastKnownWriteTime" : 4640290912935608320,
    "last_content_update" : 1514925172702,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}