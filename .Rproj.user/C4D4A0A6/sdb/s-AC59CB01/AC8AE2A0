{
    "collab_server" : "",
    "contents" : "devtools::use_package('dplyr')\n\n\n#' Adds FDR columns to the genetic interaction data\n#'\n#' @param gi_data input genetic interaction table\n#' @param nn_pair_type \"null distribution\" of GI scores used to\n#' compute FDR.Either 'broad' for all interactions with neutral\n#' pairs or 'narrow' for only neutral-neutral pairs\n#'\n#' @return gi_data with 'FDR.internal' metrics added\nadd_fdrs <- function(gi_data,\n                           nn_pair_type = 'broad'){\n  gi_data_full <- gi_data\n  gi_data <-\n    dplyr::filter(gi_data, Remove_by_Chromosomal_distance_or_SameGene == 'no')\n  \n  ddr_pairs <-\n    gi_data$Type_of_gene_i == 'DNA_repair' &\n    gi_data$Type_of_gene_j == 'DNA_repair'\n  \n  #Neutral-Neutral pairs\n  if(nn_pair_type == 'broad'){\n    #Can define all non DNA_repair - DNA_repair as neutral\n    nn_pairs <-\n    gi_data$Type_of_gene_i != 'DNA_repair' | gi_data$Type_of_gene_j != 'DNA_repair'\n  }else if(nn_pair_type == 'narrow'){\n    #Or just neutral-neutral pairs\n    nn_pairs <-\n      gi_data$Type_of_gene_i == 'Neutral' &\n      gi_data$Type_of_gene_j == 'Neutral'\n  }\n  \n  z_cols <-\n    grep('Class',\n         grep('^Z_GIS', colnames(gi_data), val = T),\n         invert = T,\n         val = T)\n  \n  z_scores <- gi_data[,z_cols]\n  z_scores_full <- gi_data_full[,z_cols]\n  \n  nn_scores <- z_scores[nn_pairs,]\n  non_nn_scores <- z_scores[ddr_pairs,]\n  \n  \n  fdr_matrix <- c()\n  \n  for(condition in colnames(z_scores)){\n    nn_scores_cond <-  nn_scores[,condition]\n    non_nn_scores_cond <- non_nn_scores[,condition]\n    non_nn_scores_cond_full <- z_scores_full[,condition]\n    \n    \n    #Hacky way to make FDRs for both positive and negative\n    #in a loop\n    unequal_tests <- c(`>=`,`<=`)\n    \n    precision_list <- lapply(unequal_tests,function(unequal_test){\n      mu <- mean(nn_scores_cond)\n      sigma <- sd(nn_scores_cond)\n      sapply(1:length(non_nn_scores_cond_full),function(i){\n        observed <- sum(unequal_test(non_nn_scores_cond_full, non_nn_scores_cond_full[i]))\n        if(all.equal(unequal_test,`<=`) == T){\n          use_lower_tail <- T\n        }else{\n          use_lower_tail <- F\n        }\n        \n        #Using normal distribuion to calculate expected\n        expected <- pnorm(non_nn_scores_cond_full[i],mean=mu,sd=sigma,lower.tail=use_lower_tail)\n        expected <- expected*length(non_nn_scores_cond_full)\n        fdr <- (expected/observed)\n        \n        #No sense returning fdr estimates >100%\n        return(min(fdr,1))\n      })\n    })\n    \n    fdrs_pos <- precision_list[[1]]\n    fdrs_neg <- precision_list[[2]]\n      comb_fdr <- cbind(fdrs_pos,fdrs_neg)\n    \n    #Return positive or negative FDRs based on the nominal sign\n    #of the interaction\n    fdr_scores <- sapply(1:nrow(comb_fdr),function(i){\n      if(z_scores_full[i,condition] < 0){\n        return(fdrs_neg[i])\n      }else{\n        return(fdrs_pos[i])\n      }\n    })\n    \n\n    fdr_matrix <- cbind(fdr_matrix,fdr_scores)\n  }\n  \n  #Add the appropriate columns at the end and fill in the data\n  drugs <- sapply(colnames(z_scores),function(name){\n    strsplit(name,split='\\\\.')[[1]][2]\n  })\n  fdr_names <- sapply(drugs,function(drug){\n    paste(c('FDR.Internal_ij.',drug),collapse='')\n  })\n  \n  colnames(fdr_matrix) <- fdr_names\n  \n  gi_data_full[,fdr_names] <- fdr_matrix\n  \n  return(gi_data_full)\n  \n}\n\n#' Update genetic interaction calls based on either Z metrics or internal FDR\n#'\n#' @param gi_data input genetic interaction table\n#' @param z_score_cols which columns correspond to Z scores - default is to use grep to find automatically\n#' @param z_class_cols which columns correspond to Z-based classifications - default is to use grep to find automatically\n#' @param fdr_cols which columns correspond to internal FDRs - default is to use grep to find automatically\n#' @param fdr_cutoff internal FDR cutoff to make GI calls - defaults to 0.05\n#' @param use_z use Z scores instead of FDR to make GI calls? defaults to False\n#' @param z_cutoff_neg if use_z is True, Z-cutoff for negative interactions\n#' @param z_cutoff_pos  if use_z is True, Z-cutoff for positive interactions\n#'\n#' @return a version of gi_data with GI calls updated\nupdate_calls <- function(gi_data,\n                         z_score_cols = NULL,\n                         fdr_cols = NULL,\n                         fdr_cutoff = 0.05,\n                         use_z = F,\n                         z_cutoff_neg = NULL,\n                         z_cutoff_pos = NULL){\n  if(is.null(z_score_cols)){\n    z_score_cols <-\n      grep('Class',\n           grep('^Z_GIS', colnames(gi_data), val = T),\n           invert = T,\n           val = T) \n  }\n  \n  z_scores <- gi_data[ , z_score_cols]\n  colnames(z_scores) <-\n    sapply(colnames(z_scores), function(name) {\n      sprintf('%s_Class', name)\n    })\n  \n  gi_data <- cbind(gi_data, z_scores)\n  \n  #if(is.null(z_class_cols)){\n  z_class_cols <-\n    grep('Class',\n         grep('^Z_GIS', colnames(gi_data), val = T),\n         invert = F,\n         val = T)  \n  #}\n  if(is.null(fdr_cols)){\n    fdr_cols <- grep('^FDR', colnames(gi_data), val = T)\n  }\n  for(i in 1:length(z_score_cols)){\n    gi_data[,z_class_cols[i]] <- \"NEUTRAL\"\n    \n    if(use_z == F){\n      neg_crit <- gi_data[,fdr_cols[i]] <= fdr_cutoff & gi_data[,z_score_cols[i]] < 0\n      pos_crit <- gi_data[,fdr_cols[i]] <= fdr_cutoff & gi_data[,z_score_cols[i]] > 0\n    }else{\n      neg_crit <- gi_data[,z_score_cols[i]] < z_cutoff_neg\n      pos_crit <- gi_data[,z_score_cols[i]] > z_cutoff_pos\n    }\n    gi_data[neg_crit,z_class_cols[i]] <- \"AGGRAVATING\"\n    gi_data[pos_crit,z_class_cols[i]] <- \"ALLEVIATING\"\n  }\n  \n  return(gi_data)\n}\n",
    "created" : 1508184094590.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2122213519",
    "id" : "AC8AE2A0",
    "lastKnownWriteTime" : 1514914641,
    "last_content_update" : 1514914641196,
    "path" : "~/Dropbox/Roth Lab/projects/BFG_GI_stats/packages/BfgGiStats/R/new_gi_calls.R",
    "project_path" : "packages/BfgGiStats/R/new_gi_calls.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}