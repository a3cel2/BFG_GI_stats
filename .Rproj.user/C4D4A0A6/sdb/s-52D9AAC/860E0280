{
    "collab_server" : "",
    "contents" : "devtools::use_package('dplyr')\n\n#' Update BFG-GI genetic interaction data\n#'\n#' @param gi_data BFG-GI dataframe\n#' @param pseudocount integer, pseudocount to add in the calculations\n#' @param count_data_grep_pattern grep pattern used to find count columns\n#' @param g_wt_vec how many generations each pool grew, in the same order as the count columns\n#'\n#' @return an updated gi_data\nupdate_gis <- function(gi_data,\n                       #Old parameter, to use only well-measured pairs, no longer needed\n                       #well_measured_cutoff = 100,\n                       #This defines the number of generations each pool grew\n                       pseudocount = 1,\n                       count_data_grep_pattern = '^C_',\n                       g_wt_vec = c(12.62,8.34,8.44,7.04,7.7,7.84,7.5,7.76,6.94,6.28)) {\n  #Define special pairs\n  same_same <-\n    sapply(gi_data$Barcode_i, function(x) {\n      strsplit(x, split = '_')[[1]][1]\n    }) == sapply(gi_data$Barcode_j, function(x) {\n      strsplit(x, split = '_')[[1]][1]\n    })\n  \n  nn_pairs <-\n    gi_data$Type_of_gene_i == 'Neutral' &\n    gi_data$Type_of_gene_j == 'Neutral' &\n    gi_data$Remove_by_Chromosomal_distance_or_SameGene == 'no'\n  \n  non_nn_unlinked_pairs <-\n    gi_data$Type_of_gene_i != 'Neutral' &\n    gi_data$Type_of_gene_j != 'Neutral' &\n    gi_data$Remove_by_Chromosomal_distance_or_SameGene == 'no'\n  \n  #Add a pseudocount of 1\n  count_data <- gi_data[, grep(count_data_grep_pattern, colnames(gi_data))] + pseudocount\n  \n  condition_sums <- apply(count_data, 2, sum)\n  freq_data <- count_data / condition_sums\n  \n  \n  #See methods for rationale of these metrics\n  f_xy_data <- count_data / condition_sums\n  r_xy_data <- (f_xy_data / f_xy_data[, 1])[, 2:ncol(f_xy_data)]\n  g_xy_data <- t(t(log2(r_xy_data)) + g_wt_vec)\n  \n  #Count error estimated by the poisson distribution\n  r_xy_error <-\n    r_xy_data * condition_sums[2:length(condition_sums)]/condition_sums[1] *\n    sqrt((sqrt(count_data[, 2:ncol(f_xy_data)]) /count_data[, 2:ncol(f_xy_data)])^2 +\n           (sqrt(count_data[, 1]) / count_data[, 1])^2)\n  \n  #Error propagation to log\n  g_xy_error <- abs(r_xy_error/(r_xy_data*log(2)))\n  \n  #wt fitness estimate and error\n  g_xy_wt <- apply(g_xy_data[nn_pairs,],2,mean)\n  g_wt_error <- apply(g_xy_data[nn_pairs,],2,function(x){sd(x)/sqrt(length(x))})\n  \n  #Normalize fitness by wildtype\n  w_xy_data <- t(t(g_xy_data) / g_xy_wt)\n  \n  genes <- unique(unlist(gi_data[, 1:2]))\n\n  \n  #Using mean now instead of median because\n  #otherwise standard deviation doesn't make sense\n  w_xy_single_genes <- t(sapply(genes, function(gene) {\n    criteria <-\n      gi_data[, 1] == gene &\n      gi_data$Type_of_gene_j == 'Neutral' |\n      gi_data[, 2] == gene & gi_data$Type_of_gene_i == 'Neutral'\n    criteria <-\n      criteria &\n      gi_data$Remove_by_Chromosomal_distance_or_SameGene == 'no'\n    \n    #Used to filter by counts, no need with error model\n    #criteria <-\n    #  criteria &\n    #  gi_data$C_ij.HetDipl >= well_measured_cutoff\n    \n    return(apply(w_xy_data[criteria, ], 2, mean))\n  }))\n  \n  g_xy_single_genes <- t(sapply(genes, function(gene) {\n    criteria <-\n      gi_data[, 1] == gene &\n      gi_data$Type_of_gene_j == 'Neutral' |\n      gi_data[, 2] == gene & gi_data$Type_of_gene_i == 'Neutral'\n    criteria <-\n      criteria &\n      gi_data$Remove_by_Chromosomal_distance_or_SameGene == 'no'\n    #Used to filter by counts, no need with error model\n    #criteria <-\n    #  criteria &\n    #  gi_data$C_ij.HetDipl >= well_measured_cutoff\n    \n    return(apply(g_xy_data[criteria, ], 2, mean))\n  }))\n  \n  \n  #Using standard error of mean as error\n  g_xy_error_single_genes <- t(sapply(genes, function(gene) {\n    criteria <-\n      gi_data[, 1] == gene &\n      gi_data$Type_of_gene_j == 'Neutral' |\n      gi_data[, 2] == gene & gi_data$Type_of_gene_i == 'Neutral'\n    criteria <-\n      criteria &\n      gi_data$Remove_by_Chromosomal_distance_or_SameGene == 'no'\n    #Used to filter by counts, no need with error model\n    #criteria <-\n    #  criteria &\n    #  gi_data$C_ij.HetDipl >= well_measured_cutoff\n      return(apply(g_xy_data[criteria, ], 2, function(x){sd(x)/sqrt(length(x))}))\n  }))\n  \n  \n  \n  \n  bc1 <- gi_data$Barcode_i\n  bc2 <- gi_data$Barcode_j\n  \n  gis <- t(sapply(1:nrow(w_xy_data), function(i) {\n    w_x <- w_xy_single_genes[bc1[i], ]\n    w_y <- w_xy_single_genes[bc2[i], ]\n    \n    w_xy <- w_xy_data[i, ]\n    \n    #Quick fix\n    #Set fitness to 0 if less than 0\n    w_x[w_x < 0] <- 0\n    w_y[w_y < 0] <- 0\n    w_xy[w_xy < 0] <- 0\n    \n    gis <- (w_xy) - (w_x * w_y)\n    \n    #Alternative log-model of genetic interactions, not used\n    #gis <- log2((w_xy + 0.01)/((w_x * w_y) + 0.01))\n    \n    #For debugging\n    #if(sum(is.na(gis) > 0)){\n    #  print(w_xy)\n    #  print(w_x)\n    #  print(w_y)\n    #  #print(c(w_xy,w_x,w_y))\n    #}\n    \n    return(gis)\n  }))\n  \n  gi_uncertainty <- t(sapply(1:nrow(w_xy_data), function(i) {\n    \n    g_xy <- g_xy_data[i, ]\n    g_x <- g_xy_single_genes[bc1[i], ]\n    g_y <- g_xy_single_genes[bc2[i], ]\n    g_wt <- g_xy_wt\n    \n    \n    g_xy_error <- g_xy_error[i, ]\n    g_x_error <- g_xy_error_single_genes[bc1[i], ]\n    g_y_error <- g_xy_error_single_genes[bc2[i], ]\n    g_wt_error <- g_wt_error\n    \n    \n    numerator <- g_xy - g_x - g_y\n    \n    gis <- numerator/g_wt\n    \n    numerator_error <- sqrt(g_xy_error^2 + g_x_error^2 + g_y_error^2)\n    \n    gi_error <- abs(gis)*sqrt((numerator_error/numerator)^2 + (g_wt_error/g_wt)^2)\n    \n    return(gi_error)\n  }))\n  \n  \n  \n  #Modify data to replace old definition with new definitions\n  gi_data[, grep('^GI', colnames(gi_data))] <-\n    gis\n  z_cols <-\n    grep('Class',\n         grep('^Z_GIS', colnames(gi_data), val = T),\n         invert = T,\n         val = T)\n  gi_data[, z_cols] <- gis / gi_uncertainty\n  \n  return(gi_data)\n}",
    "created" : 1508195246700.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "608982835",
    "id" : "860E0280",
    "lastKnownWriteTime" : 1510343875,
    "last_content_update" : 1510343875821,
    "path" : "~/Dropbox/Roth Lab/projects/BFG_GI_stats/packages/BfgGiStats/R/new_gis.R",
    "project_path" : "packages/BfgGiStats/R/new_gis.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}