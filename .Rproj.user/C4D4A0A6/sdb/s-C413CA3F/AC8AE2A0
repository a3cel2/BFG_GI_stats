{
    "collab_server" : "",
    "contents" : "devtools::use_package('dplyr')\n\nadd_fdrs <- function(gi_data,\n                            fdr_positive = 0.01,\n                            fdr_negative = 0.01,\n                           nn_pair_type = 'broad'){\n  gi_data_full <- gi_data\n  gi_data <-\n    dplyr::filter(gi_data, Remove_by_Chromosomal_distance_or_SameGene == 'no')\n  \n  ddr_pairs <-\n    gi_data$Type_of_gene_i == 'DNA_repair' &\n    gi_data$Type_of_gene_j == 'DNA_repair'\n  \n  #Neutral-Neutral pairs\n  if(nn_pair_type == 'broad'){\n    #Can define all non DNA_repair - DNA_repair as neutral\n    nn_pairs <-\n    gi_data$Type_of_gene_i != 'DNA_repair' | gi_data$Type_of_gene_j != 'DNA_repair'\n  }else if(nn_pair_type == 'narrow'){\n    #Or just neutral-neutral pairs\n    nn_pairs <-\n      gi_data$Type_of_gene_i == 'Neutral' &\n      gi_data$Type_of_gene_j == 'Neutral'\n  }\n  \n  z_cols <-\n    grep('Class',\n         grep('^Z_GIS', colnames(gi_data), val = T),\n         invert = T,\n         val = T)\n  \n  z_scores <- gi_data[,z_cols]\n  z_scores_full <- gi_data_full[,z_cols]\n  \n  nn_scores <- z_scores[nn_pairs,]\n  non_nn_scores <- z_scores[ddr_pairs,]\n  \n  #ret_table <- c()\n  fdr_matrix <- c()\n  \n  for(condition in colnames(z_scores)){\n    print(condition)\n    nn_scores_cond <-  nn_scores[,condition]\n    non_nn_scores_cond <- non_nn_scores[,condition]\n    \n    unequal_tests <- c(`>=`,`<=`)\n    \n    precision_list <- lapply(unequal_tests,function(unequal_test){\n      sapply(1:length(non_nn_scores_cond),function(i){\n        observed <- sum(unequal_test(non_nn_scores_cond, non_nn_scores_cond[i]))\n        expected <- sum(unequal_test(nn_scores_cond, non_nn_scores_cond[i]))\n        \n        expected <- expected/length(nn_scores_cond)\n        expected <- expected*length(non_nn_scores_cond)\n        fdr <- (expected/observed)\n        fdr <- min(fdr,1)\n        return(fdr)\n      })\n    })\n    \n    pos_prec_vec <- precision_list[[1]]\n    neg_prec_vec <- precision_list[[2]]\n    pos_prec_func <- approxfun(non_nn_scores_cond,pos_prec_vec)\n    neg_prec_func <- approxfun(non_nn_scores_cond,neg_prec_vec)\n    \n    fdrs_pos <- pos_prec_func(z_scores_full[,condition])\n    fdrs_neg <- neg_prec_func(z_scores_full[,condition])\n    \n    #FDR is never 0\n    #fdrs_neg[fdrs_neg == 0] <- min(fdrs_neg[fdrs_neg > 0],na.rm=T)\n    #fdrs_pos[fdrs_pos == 0] <- min(fdrs_pos[fdrs_pos > 0],na.rm=T)\n    \n    #Extreme values from linked pairs get assigned lowest FDR\n    fdrs_neg[z_scores_full[,condition] <= min(non_nn_scores_cond)] <- min(fdrs_neg,na.rm=T)\n    fdrs_pos[z_scores_full[,condition] >= max(non_nn_scores_cond)] <- min(fdrs_pos,na.rm=T)\n  \n    #fdr_scores <- fdrs_neg\n    comb_fdr <- cbind(fdrs_pos,fdrs_neg)\n    \n    fdr_scores <- sapply(1:nrow(comb_fdr),function(i){\n      if(z_scores_full[i,condition] < 0){\n        return(fdrs_neg[i])\n      }else{\n        return(fdrs_pos[i])\n      }\n    })\n    \n\n    fdr_matrix <- cbind(fdr_matrix,fdr_scores)\n    \n    \n    \n    #fdr_cutoff_neg <- max(non_nn_scores_cond[neg_prec_vec < fdr_negative])\n    #fdr_cutoff_pos <- min(non_nn_scores_cond[pos_prec_vec < fdr_positive])\n    \n    #positive_inters <- sum(non_nn_scores_cond > fdr_cutoff_pos)\n    #negative_inters <- sum(non_nn_scores_cond < fdr_cutoff_neg)\n    \n    #ret_table <- cbind(ret_table,c(fdr_cutoff_pos,fdr_cutoff_neg,positive_inters,negative_inters))\n  }\n  #rownames(ret_table) <- c('Z cutoff Positive',\n  #                         'Z cutoff Negative',\n  #                         'Positive Interactions at Cutoff',\n  #                         'Negative Interactions at Cutoff')\n  #ret_table <- as.data.frame(ret_table)\n  drugs <- sapply(colnames(z_scores),function(name){\n    strsplit(name,split='\\\\.')[[1]][2]\n  })\n  \n  #colnames(ret_table) <- drugs\n  \n  fdr_names <- sapply(drugs,function(drug){\n    paste(c('FDR.Internal_ij.',drug),collapse='')\n  })\n  \n  colnames(fdr_matrix) <- fdr_names\n  \n  gi_data_full[,fdr_names] <- fdr_matrix\n  \n  return(gi_data_full)\n  #return(ret_table)\n  \n}\n\nupdate_calls <- function(gi_data,\n                         z_table,\n                         z_score_cols = NULL,\n                         z_class_cols = NULL,\n                         fdr_cols = NULL,\n                         fdr_cutoff = 0.01,\n                         use_z = F,\n                         z_cutoff_neg = NULL,\n                         z_cutoff_pos = NULL){\n  if(is.null(z_score_cols)){\n    z_score_cols <-\n      grep('Class',\n           grep('^Z_GIS', colnames(gi_data), val = T),\n           invert = T,\n           val = T) \n  }\n  if(is.null(z_class_cols)){\n    z_class_cols <-\n      grep('Class',\n           grep('^Z_GIS', colnames(gi_data), val = T),\n           invert = F,\n           val = T)  \n  }\n  if(is.null(fdr_cols)){\n    fdr_cols <- grep('^FDR', colnames(gi_data), val = T)\n  }\n  for(i in 1:length(z_score_cols)){\n    gi_data[,z_class_cols[i]] <- \"NEUTRAL\"\n    \n    if(use_z == F){\n      neg_crit <- gi_data[,fdr_cols[i]] <= fdr_cutoff & gi_data[,z_score_cols[i]] < 0\n      pos_crit <- gi_data[,fdr_cols[i]] <= fdr_cutoff & gi_data[,z_score_cols[i]] > 0\n    }else{\n      neg_crit <- gi_data[,z_score_cols[i]] < z_cutoff_neg\n      pos_crit <- gi_data[,z_score_cols[i]] > z_cutoff_pos\n    }\n    gi_data[neg_crit,z_class_cols[i]] <- \"AGGRAVATING\"\n    gi_data[pos_crit,z_class_cols[i]] <- \"ALLEVIATING\"\n  }\n  \n  return(gi_data)\n}\n",
    "created" : 1508184094590.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2762821135",
    "id" : "AC8AE2A0",
    "lastKnownWriteTime" : 1508440393,
    "last_content_update" : 1508440393265,
    "path" : "~/Dropbox/Roth Lab/projects/BFG_GI_stats/packages/BfgGiStats/R/new_gi_calls.R",
    "project_path" : "packages/BfgGiStats/R/new_gi_calls.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}